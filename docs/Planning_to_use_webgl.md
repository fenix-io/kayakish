# WebGL Visualization with Three.js - Planning Document

**Version:** 1.0  
**Date:** February 18, 2026  
**Status:** Planning Phase

---

## 1. Executive Summary

This document outlines the plan to replace the current 2D canvas-based hull visualizer with a modern WebGL-based 3D renderer using Three.js. The new visualizer will provide realistic surface rendering with lighting, shadows, and interactive 3D navigation, while maintaining the existing wireframe option for technical analysis.

### Goals
- ✅ Create realistic 3D surface rendering of kayak hulls
- ✅ Add interactive camera controls (orbit, zoom, pan)
- ✅ Implement proper lighting and shadows
- ✅ Maintain wireframe mode as an optional overlay
- ✅ Improve user experience with smooth 3D navigation
- ✅ Maintain backward compatibility with existing API

---

## 2. Current State Analysis

### 2.1 Existing Visualization System

**Technology Stack:**
- HTML5 Canvas 2D Context
- Pure JavaScript (no libraries)
- Manual projection calculations for multiple views

**Current Features:**
- Multiple fixed view modes (iso, side, top, front, 3d)
- Wireframe rendering of curves and profiles
- Color-coded display (above/below waterline)
- Waterline plane visualization
- Main profile cross-sections display

**Limitations:**
- Limited interactivity (no rotation, restricted zoom)
- No surface rendering (wireframe only)
- Manual view switching (no smooth transitions)
- No lighting or depth perception
- 2D projections of 3D data

### 2.2 Available Data from API

The `/hulls/{hull_name}` endpoint provides:

```json
{
  "name": "string",
  "description": "string",
  "curves": [
    {
      "name": "string",
      "mirrored": boolean,
      "points": [[x, y, z], ...]
    }
  ],
  "main_profiles": [
    {
      "x": float,
      "points": [[x, y, z], ...]
    }
  ],
  "waterline": float,
  "min_x": float, "max_x": float,
  "min_y": float, "max_y": float,
  "min_z": float, "max_z": float
}
```

**Data Structure:**
- **Longitudinal curves**: Define hull shape along length (gunwale, chine, keel, etc.)
- **Transverse profiles**: Cross-sections at discrete X-stations
- Both datasets provide 3D point arrays perfect for mesh generation

---

## 3. Three.js Solution Architecture

### 3.1 Technology Stack

**Core Libraries:**
- **Three.js** (r160+): WebGL rendering engine
- **OrbitControls**: Interactive camera navigation
- **BufferGeometry**: Efficient mesh representation

**No Additional Build Required:**
- Three.js will be loaded via CDN (ESM modules)
- No webpack/bundler needed (maintains vanilla JS approach)
- Compatible with current project structure

### 3.2 Rendering Approach

**Surface Mesh Generation Strategy:**

We have two data sources for creating the hull surface:

1. **Longitudinal curves** (e.g., 8-10 curves from stern to bow)
   - Each curve has 30-50 points along the length
   - Curves run parallel (keel, chine, gunwale, etc.)

2. **Main profiles** (e.g., 10-20 transverse cross-sections)
   - Each profile has 20-40 points around the perimeter
   - Profiles are perpendicular to curves

**Recommended Approach: Profile-Based Lofting with Adaptive Triangulation**

Generate the hull surface by connecting adjacent transverse profiles. **Profiles are pre-computed by the backend** and already handle the complexity of irregular curves (varying lengths, multiple keels/chines, deck/cockpit curves, etc.).

```
Profile 1    Profile 2    Profile 3
   |            |            |
   •------------•------------•   ← Gunwale points
   |\           |\           |\
   | \          | \          | \
   |  \         |  \         |  \
   |   •--------|---•--------|---•  ← Chine points
   |   |\       |   |\       |   |\
   |   | \      |   | \      |   | \
   |   |  •-----|---|--•-----|---|--• ← Keel points
   |   |        |   |        |   |
```

**Why This Approach Works for Irregular Hulls:**

✅ **Backend handles complexity**: Profiles are generated by interpolating ALL curves at each X-station, automatically handling:
   - Curves with varying lengths (some full-length, some partial)
   - Multiple keels, chines, gunnels
   - Additional features (deck, cockpit, etc.)
   - Curves starting/ending mid-hull

✅ **Closed loops**: Each profile forms a complete perimeter at that station

✅ **Sufficient density**: Backend generates 10-20+ profiles, capturing topology changes

**Challenge: Point Correspondence**

Adjacent profiles may have **different numbers of points** if:
- A curve starts or ends between profiles
- Backend uses adaptive sampling
- Local geometry complexity varies

**Solution: Arc-Length Re-parameterization**

```javascript
function createMeshBetweenProfiles(profile1, profile2) {
  // 1. Calculate arc-length parameter for each point (0 to 1 around perimeter)
  const params1 = calculateArcLengthParams(profile1.points);
  const params2 = calculateArcLengthParams(profile2.points);
  
  // 2. Resample both profiles to common parameter count (e.g., 50 points)
  const targetCount = Math.max(profile1.points.length, profile2.points.length);
  const resampled1 = resampleByArcLength(profile1.points, params1, targetCount);
  const resampled2 = resampleByArcLength(profile2.points, params2, targetCount);
  
  // 3. Now both profiles have same point count - create quad faces
  for (let i = 0; i < targetCount; i++) {
    const i_next = (i + 1) % targetCount;  // Wrap around
    
    // Create two triangles forming a quad
    addTriangle(resampled1[i], resampled2[i], resampled2[i_next]);
    addTriangle(resampled1[i], resampled2[i_next], resampled1[i_next]);
  }
}

function calculateArcLengthParams(points) {
  // Calculate cumulative arc length along the profile perimeter
  const distances = [0];
  let totalLength = 0;
  
  for (let i = 1; i < points.length; i++) {
    const dist = distance3D(points[i-1], points[i]);
    totalLength += dist;
    distances.push(totalLength);
  }
  
  // Normalize to [0, 1]
  return distances.map(d => d / totalLength);
}

function resampleByArcLength(points, params, targetCount) {
  const resampled = [];
  for (let i = 0; i < targetCount; i++) {
    const t = i / targetCount;  // Target parameter [0, 1]
    
    // Find the two original points that bracket this parameter
    const idx = binarySearch(params, t);
    
    // Interpolate between points[idx] and points[idx+1]
    const p1 = points[idx];
    const p2 = points[(idx + 1) % points.length];
    const localT = (t - params[idx]) / (params[idx+1] - params[idx]);
    
    resampled.push(lerp3D(p1, p2, localT));
  }
  return resampled;
}
```

**Alternative: Delaunay Triangulation for Complex Cases**

For extremely irregular topology (if simple resampling fails):
```javascript
// Use earcut or similar library for 2D triangulation
// Project profile points to local 2D space, triangulate, then map back to 3D
// Useful for end caps (bow/stern) or complex cockpit cutouts
```

**Algorithm (Updated):**
1. Iterate through consecutive profile pairs
2. Calculate arc-length parameters for both profiles
3. Resample both to common point count (maintains shape)
4. Create quad faces between corresponding points
5. Calculate smooth normals for proper lighting

**Advantages:**
- Handles varying point counts between profiles
- Preserves shape accurately (arc-length parameterization)
- Natural hull representation regardless of curve complexity
- Profiles pre-computed by backend (no curve interpolation needed)
- Smooth surfaces across beam (Y-Z plane)
- Robust to topology changes (curves starting/ending)

**Testing Strategy:**
- Test with simple hulls (single keel, chine, gunwale)
- Test with complex hulls (multiple keels, partial curves)
- Test with deck/cockpit features
- Verify smooth transitions where curves start/end

### 3.3 Component Architecture

```
visualization/
├── index.html              (updated with Three.js includes)
├── styles.css              (minor updates for WebGL canvas)
├── script.js               (existing API/UI logic - minimal changes)
└── webgl-renderer.js       (NEW - Three.js visualization module)
    ├── class HullRenderer
    │   ├── init()          Initialize Three.js scene
    │   ├── createMesh()    Build hull geometry from data
    │   ├── render()        Render loop
    │   ├── setWireframe()  Toggle wireframe mode
    │   ├── updateCamera()  View presets (iso, side, top, front)
    │   └── dispose()       Cleanup resources
    └── utility functions
```

---

## 4. Detailed Implementation Plan

### Phase 1: Three.js Setup & Scene Configuration

**Tasks:**
- **W1.1**: Add Three.js library via CDN (ESM modules)
  - Use importmap in HTML for clean imports
  - No build step required
  
- **W1.2**: Create `webgl-renderer.js` module
  - Define `HullRenderer` class
  - Initialize WebGL renderer, scene, camera
  - Set up basic lighting (ambient + directional)
  
- **W1.3**: Add OrbitControls for camera interaction
  - Mouse drag to rotate
  - Scroll to zoom
  - Right-drag to pan
  - Auto-rotate option
  
- **W1.4**: Configure responsive canvas
  - Dynamic resizing
  - Maintain aspect ratio
  - Handle device pixel ratio (retina displays)

**Expected Output:**
- Empty 3D scene with working camera controls
- Grid helper and axes for reference

---

### Phase 2: Hull Surface Mesh Generation

**Tasks:**
- **W2.1**: Implement profile-based mesh builder with arc-length resampling
  ```javascript
  function buildHullMesh(profiles, curves) {
    // Create BufferGeometry
    // Resample profiles to common point count (arc-length parameterization)
    // Generate vertices from resampled profiles
    // Create face indices (triangles) between adjacent profiles
    // Calculate smooth normals
    // Return THREE.Mesh
  }
  ```

- **W2.2**: Handle irregular geometry and topology changes
  - Implement arc-length resampling for profiles with different point counts
  - Test with hulls having curves of varying lengths
  - Test with multiple keels, chines, gunnels
  - Test with partial curves (deck, cockpit features)
  - Verify smooth transitions where curves start/end
  
- **W2.3**: Handle symmetry and closure
  - Port/starboard symmetry (already in profile data)
  - Bow/stern end caps (if profiles don't close naturally)
  - Keel closure at centerline
  - Validate closed surface (no gaps)
  
- **W2.4**: Add waterline plane visualization
  - Semi-transparent plane at Z = waterline
  - Water-like material (cyan, transparent)
  - Optional toggle
  
- **W2.5**: Texture and material setup
  - Phong or Physical material for realistic shading
  - Vertex colors for above/below waterline regions
  - Specularity for wet hull appearance
  - Double-sided rendering for incomplete meshes

**Expected Output:**
- Solid 3D hull surface with proper shading
- Distinguishable above/below waterline regions
- Correctly handles irregular curve geometry
- Smooth surface even with topology changes

---

### Phase 3: Wireframe & Technical Overlays

**Tasks:**
- **W3.1**: Implement wireframe overlay mode
  - Optional wireframe rendering on top of surface
  - Use `LineSegments` with `EdgesGeometry`
  - Toggle button in UI
  
- **W3.2**: Draw longitudinal curves as lines
  - Render original curve data as LineSegments
  - Different colors (matching current scheme)
  - Optional toggle
  
- **W3.3**: Draw profile cross-sections
  - Render profile loops at stations
  - Semi-transparent green (match current style)
  - Optional toggle
  
- **W3.4**: Add measurement overlays
  - Length, beam, depth annotations
  - Waterline level indicator
  - Station markers

**Expected Output:**
- Multiple visualization modes:
  - Pure surface (photo-realistic)
  - Wireframe only (technical)
  - Surface + wireframe overlay (hybrid)
  - Surface + curves + profiles (full technical)

---

### Phase 4: Lighting, Shadows & Visual Polish

**Tasks:**
- **W4.1**: Implement shadow mapping
  - DirectionalLight with shadow camera
  - Shadow receiving plane (ground/water)
  - Shadow quality settings
  
- **W4.2**: Add environment effects
  - HDR environment map (optional)
  - Ambient occlusion hints
  - Realistic water surface (ground plane)
  
- **W4.3**: Implement camera presets
  - Isometric view (current default)
  - Profile view (side elevation)
  - Plan view (top down)
  - Bow/stern views
  - Smooth animated transitions
  
- **W4.4**: Add visual feedback
  - Loading indicator during mesh generation
  - FPS counter (debug mode)
  - Render quality settings

**Expected Output:**
- Professional-looking 3D visualization
- Smooth camera transitions
- Realistic lighting and depth perception

---

### Phase 5: UI Integration & Migration

**Tasks:**
- **W5.1**: Update existing UI controls
  - Replace view dropdown with camera preset buttons
  - Add rendering mode toggle (surface/wireframe/hybrid)
  - Add quality settings (shadows on/off, etc.)
  
- **W5.2**: Integrate with existing script.js
  - Call `HullRenderer` instead of canvas drawing
  - Maintain existing data loading logic
  - Keep stability/resistance tabs unchanged
  
- **W5.3**: Update legend and help text
  - Document new camera controls
  - Explain rendering modes
  - Add keyboard shortcuts reference
  
- **W5.4**: Fallback handling
  - Detect WebGL support
  - Graceful degradation to 2D canvas
  - Error messages for unsupported browsers

**Expected Output:**
- Seamless replacement of canvas visualization
- Minimal impact on existing features
- Backward compatibility maintained

---

### Phase 6: Testing & Optimization

**Tasks:**
- **W6.1**: Performance testing
  - Test with complex hulls (many curves/profiles)
  - Optimize geometry (reduce vertices if needed)
  - Implement LOD (Level of Detail) if necessary
  
- **W6.2**: Cross-browser testing
  - Chrome, Firefox, Safari, Edge
  - Mobile browsers (touch controls)
  
- **W6.3**: Visual quality verification
  - Compare rendering with real hull photos
  - Verify waterline accuracy
  - Check symmetry and proportions
  
- **W6.4**: User acceptance testing
  - Gather feedback on usability
  - Tune default camera positions
  - Adjust lighting for clarity

**Expected Output:**
- Smooth 60fps rendering
- Consistent appearance across browsers
- Positive user feedback

---

## 5. Technical Specifications

### 5.1 Mesh Generation Details

**Complete Vertex Calculation (Handles Irregular Geometry):**
```javascript
function buildHullGeometry(profiles) {
  const vertices = [];
  const indices = [];
  const normals = [];
  const colors = [];
  
  // Process each pair of adjacent profiles
  for (let p = 0; p < profiles.length - 1; p++) {
    const profile1 = profiles[p];
    const profile2 = profiles[p + 1];
    
    // Resample both profiles to common point count
    const targetCount = Math.max(profile1.points.length, profile2.points.length, 50);
    const resampled1 = resampleProfileByArcLength(profile1.points, targetCount);
    const resampled2 = resampleProfileByArcLength(profile2.points, targetCount);
    
    // Create quad faces between resampled profiles
    for (let i = 0; i < targetCount; i++) {
      const i_next = (i + 1) % targetCount;
      
      const p1 = resampled1[i];      // Current profile, current point
      const p2 = resampled1[i_next];  // Current profile, next point
      const p3 = resampled2[i];      // Next profile, current point
      const p4 = resampled2[i_next];  // Next profile, next point
      
      const vertexBase = vertices.length / 3;
      
      // Add vertices
      vertices.push(...p1, ...p2, ...p3, ...p4);
      
      // Add vertex colors (based on waterline)
      const waterline = hullData.waterline;
      colors.push(...getVertexColor(p1[2], waterline));
      colors.push(...getVertexColor(p2[2], waterline));
      colors.push(...getVertexColor(p3[2], waterline));
      colors.push(...getVertexColor(p4[2], waterline));
      
      // Create two triangles (counter-clockwise winding)
      indices.push(
        vertexBase + 0, vertexBase + 2, vertexBase + 3,  // Triangle 1: p1, p3, p4
        vertexBase + 0, vertexBase + 3, vertexBase + 1   // Triangle 2: p1, p4, p2
      );
    }
  }
  
  // Create BufferGeometry
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();  // Smooth shading
  
  return geometry;
}

function resampleProfileByArcLength(points, targetCount) {
  // Calculate cumulative arc lengths
  const arcLengths = [0];
  let totalLength = 0;
  
  for (let i = 1; i < points.length; i++) {
    const dx = points[i][0] - points[i-1][0];
    const dy = points[i][1] - points[i-1][1];
    const dz = points[i][2] - points[i-1][2];
    totalLength += Math.sqrt(dx*dx + dy*dy + dz*dz);
    arcLengths.push(totalLength);
  }
  
  // Resample at uniform arc length intervals
  const resampled = [];
  for (let i = 0; i < targetCount; i++) {
    const targetLength = (i / targetCount) * totalLength;
    
    // Find segment containing this arc length
    let segIdx = 0;
    for (let j = 0; j < arcLengths.length - 1; j++) {
      if (targetLength >= arcLengths[j] && targetLength <= arcLengths[j + 1]) {
        segIdx = j;
        break;
      }
    }
    
    // Interpolate within segment
    const p1 = points[segIdx];
    const p2 = points[(segIdx + 1) % points.length];
    const segLength = arcLengths[segIdx + 1] - arcLengths[segIdx];
    const localT = segLength > 0 ? (targetLength - arcLengths[segIdx]) / segLength : 0;
    
    const x = p1[0] + (p2[0] - p1[0]) * localT;
    const y = p1[1] + (p2[1] - p1[1]) * localT;
    const z = p1[2] + (p2[2] - p1[2]) * localT;
    
    resampled.push([x, y, z]);
  }
  
  return resampled;
}

function getVertexColor(zCoord, waterline) {
  const isAboveWater = zCoord >= waterline;
  return isAboveWater 
    ? [0.0, 0.0, 0.8]  // Dark blue above waterline
    : [0.6, 0.8, 1.0]; // Light blue below waterline
}
```

**Handling Special Cases:**

1. **End Caps (Bow/Stern):**
   - If profiles don't naturally close at ends, create cap geometry
   - Use Delaunay triangulation for complex shapes
   - Or connect all perimeter points to a central point

2. **Deck/Cockpit Openings:**
   - Profiles with interior holes need special triangulation
   - Use earcut.js or similar 2D triangulation library
   - Project to local 2D plane, triangulate, map back to 3D

3. **Curves Starting/Ending Mid-Hull:**
   - Arc-length resampling naturally handles this
   - Profiles adapt smoothly as curves appear/disappear
   - No special handling needed (backend generates profiles correctly)

**Normal Calculation:**
- Use averaged face normals for smooth shading
- Three.js `computeVertexNormals()` handles this automatically
- For hard edges (chines), consider splitting vertices

**Optimization:**
- Use `BufferGeometry` (not the deprecated `Geometry`)
- Interleave vertex attributes for better cache performance
- Consider geometry instancing for multiple hulls
- Use TypedArrays for large datasets
- Implement frustum culling if rendering many hulls

### 5.2 Material Configuration

**Hull Surface Material:**
```javascript
const hullMaterial = new THREE.MeshPhongMaterial({
  color: 0x2196F3,           // Blue hull
  specular: 0x555555,        // Subtle shininess
  shininess: 30,
  side: THREE.DoubleSide,    // Visible from both sides
  flatShading: false         // Smooth shading
});
```

**Waterline Material:**
```javascript
const waterMaterial = new THREE.MeshPhongMaterial({
  color: 0x00FFFF,          // Cyan
  transparent: true,
  opacity: 0.3,
  side: THREE.DoubleSide
});
```

**Dynamic Coloring (above/below waterline):**
- Option 1: Vertex colors (computed during mesh generation)
- Option 2: Two separate meshes
- Recommended: Vertex colors for flexibility

### 5.3 Camera Configuration

**Initial Setup:**
```javascript
const camera = new THREE.PerspectiveCamera(
  45,                         // FOV
  aspect,                     // Aspect ratio
  0.1,                        // Near plane
  1000                        // Far plane
);

// Initial position (isometric-ish view)
camera.position.set(
  hullLength * 1.5,          // X: Side offset
  hullLength * 1.2,          // Y: Port/starboard offset
  hullDepth * 3              // Z: Above hull
);
camera.lookAt(hullCenter);
```

**OrbitControls Setup:**
```javascript
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;     // Smooth motion
controls.dampingFactor = 0.05;
controls.minDistance = hullLength * 0.5;
controls.maxDistance = hullLength * 5;
controls.maxPolarAngle = Math.PI * 0.95;  // Don't flip upside down
```

### 5.4 Lighting Configuration

**Three-Point Lighting Setup:**
```javascript
// 1. Key light (main directional light)
const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
keyLight.position.set(5, 10, 7.5);
keyLight.castShadow = true;

// 2. Fill light (soften shadows)
const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
fillLight.position.set(-5, 5, -5);

// 3. Ambient light (base illumination)
const ambientLight = new THREE.AmbientLight(0x404040, 0.5);

// Add all to scene
scene.add(keyLight, fillLight, ambientLight);

// Optional: Hemisphere light for outdoor feel
const hemiLight = new THREE.HemisphereLight(
  0x87CEEB,  // Sky color
  0x8B4513,  // Ground color
  0.4
);
```

---

## 6. Integration Points

### 6.1 Minimal Changes to Existing Code

**index.html:**
```html
<!-- Add before closing </head> -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<!-- Add before script.js -->
<script type="module" src="webgl-renderer.js"></script>
```

**script.js changes:**
```javascript
// At top:
import { HullRenderer } from './webgl-renderer.js';

let hullRenderer = null;

// In setupCanvas():
function setupCanvas() {
  const container = document.querySelector('.canvas-container');
  hullRenderer = new HullRenderer(container);
  hullRenderer.init();
  
  // Handle resize
  window.addEventListener('resize', () => {
    hullRenderer.resize();
  });
}

// In drawHull():
function drawHull(hull) {
  if (hullRenderer) {
    hullRenderer.render(hull);
  }
}

// In view change handler:
document.getElementById('viewSelect').addEventListener('change', (e) => {
  hullRenderer.setCameraPreset(e.target.value);
});
```

**styles.css:**
```css
/* Change canvas to support WebGL */
#hullCanvas {
  width: 100%;
  height: 100%;
  display: block;
  cursor: grab;  /* Indicate draggable */
}

#hullCanvas:active {
  cursor: grabbing;
}
```

### 6.2 New UI Controls

**Add to visualization tab:**
```html
<div class="controls">
  <label for="viewSelect">Camera:</label>
  <select id="viewSelect">
    <option value="iso">Isometric</option>
    <option value="side">Side Profile</option>
    <option value="top">Plan View</option>
    <option value="front">Front View</option>
    <option value="free">Free Orbit</option>
  </select>
  
  <label for="renderMode">Display:</label>
  <select id="renderMode">
    <option value="surface">Shaded Surface</option>
    <option value="wireframe">Wireframe Only</option>
    <option value="both">Surface + Wireframe</option>
    <option value="technical">Surface + Curves + Profiles</option>
  </select>
  
  <label>
    <input type="checkbox" id="showShadows" checked>
    Shadows
  </label>
  
  <label>
    <input type="checkbox" id="showWaterline" checked>
    Waterline
  </label>
</div>
```

---

## 7. Benefits & Trade-offs

### 7.1 Advantages

✅ **User Experience:**
- Intuitive 3D navigation (drag to rotate)
- Better depth perception with lighting
- Realistic hull representation
- Smooth interactions

✅ **Technical:**
- Hardware-accelerated rendering (60fps)
- Scalable to complex geometry
- Modern, maintainable codebase
- Rich ecosystem (Three.js examples)

✅ **Features:**
- Easy to add new visualizations (stability heeling animation, resistance flow lines)
- Export capabilities (screenshots, 3D models)
- VR/AR potential (future enhancement)

### 7.2 Considerations

⚠️ **Browser Support:**
- Requires WebGL (95%+ of modern browsers)
- Falls back to 2D canvas for old browsers
- Mobile support varies (mostly good)

⚠️ **Performance:**
- More resource-intensive than 2D canvas
- Acceptable trade-off for benefits
- Optimizations available if needed

⚠️ **Learning Curve:**
- Team needs basic Three.js knowledge
- Extensive documentation available
- Many examples online

⚠️ **File Size:**
- Three.js core ~600KB (cached via CDN)
- Minimal impact on load time
- Loaded on-demand

---

## 8. Risk Mitigation

### 8.1 Fallback Strategy

**WebGL Detection:**
```javascript
function hasWebGLSupport() {
  try {
    const canvas = document.createElement('canvas');
    return !!(
      window.WebGLRenderingContext &&
      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
    );
  } catch (e) {
    return false;
  }
}

// In initialization:
if (hasWebGLSupport()) {
  hullRenderer = new HullRenderer(container);
} else {
  console.warn('WebGL not supported, using 2D canvas fallback');
  setup2DCanvas();  // Keep old implementation
}
```

### 8.2 Progressive Enhancement

- Keep existing 2D canvas code as fallback
- Hide WebGL-specific controls if not supported
- Display message suggesting browser upgrade

### 8.3 Testing Strategy

- Test on target browsers before full rollout
- Monitor performance metrics
- Collect user feedback early
- Have rollback plan if issues arise

---

## 9. Timeline Estimate

| Phase | Description | Time Estimate | Dependencies |
|-------|-------------|---------------|--------------|
| Phase 1 | Three.js Setup | 2-4 hours | None |
| Phase 2 | Mesh Generation | 4-6 hours | Phase 1 |
| Phase 3 | Wireframe/Overlays | 3-4 hours | Phase 2 |
| Phase 4 | Lighting/Polish | 3-4 hours | Phase 2, 3 |
| Phase 5 | UI Integration | 2-3 hours | Phase 1-4 |
| Phase 6 | Testing/Optimization | 4-6 hours | Phase 5 |
| **TOTAL** | | **18-27 hours** | |

**Recommended Approach:**
- Implement in week-long sprint
- Deploy phases incrementally
- Gather feedback after Phase 5
- Polish in Phase 6 based on feedback

---

## 10. Success Criteria

### 10.1 Functional Requirements

- ✅ Hull surface renders correctly in 3D
- ✅ Camera can be rotated, zoomed, panned smoothly
- ✅ Wireframe mode available as option
- ✅ Above/below waterline clearly distinguishable
- ✅ Performance maintains 60fps with typical hulls
- ✅ Works in Chrome, Firefox, Safari, Edge

### 10.2 Non-Functional Requirements

- ✅ No degradation of existing features (stability, resistance tabs)
- ✅ Code is maintainable and documented
- ✅ Mobile-friendly (touch controls work)
- ✅ Load time acceptable (<2s additional)

### 10.3 User Acceptance

- ✅ Users find 3D view more intuitive than 2D projections
- ✅ No complaints about performance or usability
- ✅ Support tickets decrease (better visualization = fewer questions)

---

## 11. Future Enhancements

Once base WebGL visualization is working, consider:

### 11.1 Advanced Features
- **Animated heeling**: Show stability analysis as animated rotation
- **Resistance flow lines**: Visualize water flow during resistance analysis
- **Multiple hulls comparison**: Side-by-side 3D comparison
- **Section cuts**: Interactive plane that cuts through hull
- **Annotations**: 3D labels for key dimensions

### 11.2 Export Capabilities
- **Screenshot**: Save current view as image
- **3D model export**: STL, OBJ formats for 3D printing
- **Video export**: Record turntable animation

### 11.3 Interactive Tools
- **Measurement tool**: Click two points to measure distance
- **Point selection**: Click on hull to see coordinates
- **Waterline adjustment**: Drag waterline plane up/down

### 11.4 Visual Themes
- **Material presets**: Fiberglass, wood, carbon fiber appearance
- **Environment presets**: Ocean, lake, workshop, showroom
- **Color schemes**: User-definable hull colors

---

## 12. Conclusion

Migrating to Three.js for hull visualization is highly recommended and feasible. The existing data structure (curves + profiles) is perfect for generating 3D surface meshes. The implementation can be done incrementally with minimal risk, while providing significant improvements to user experience and opening doors for future enhancements.

**Recommendation: Proceed with implementation following the phased approach outlined above.**

---

## 13. References

### Three.js Documentation
- Official docs: https://threejs.org/docs/
- Examples: https://threejs.org/examples/
- Fundamentals: https://threejs.org/manual/

### Related Examples
- Mesh generation: https://threejs.org/examples/#webgl_geometry_dynamic
- OrbitControls: https://threejs.org/examples/#misc_controls_orbit
- Shadows: https://threejs.org/examples/#webgl_shadowmap

### Performance
- Optimization guide: https://discoverthreejs.com/tips-and-tricks/
- BufferGeometry best practices: https://threejs.org/docs/#api/en/core/BufferGeometry

---

**Document Control:**
- Created: February 18, 2026
- Last Updated: February 18, 2026
- Author: GitHub Copilot
- Status: Planning - Awaiting Approval
